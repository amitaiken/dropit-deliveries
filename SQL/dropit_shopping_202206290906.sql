--
-- Script was generated by Devart dbForge Studio 2020 for MySQL, Version 9.0.567.0
-- Product home page: http://www.devart.com/dbforge/mysql/studio
-- Script date 6/29/2022 9:06:15 AM
-- Server version: 5.7.29
-- Client version: 4.1
--

-- 
-- Disable foreign keys
-- 
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;

-- 
-- Set SQL mode
-- 
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

-- 
-- Set character set the client will use to send SQL statements to the server
--
SET NAMES 'utf8';

--
-- Set default database
--
USE dropit_shopping;

--
-- Drop function `FN_ScheduleTimeslots`
--
DROP FUNCTION IF EXISTS FN_ScheduleTimeslots;

--
-- Drop procedure `SP_DeliveryCancel`
--
DROP PROCEDURE IF EXISTS SP_DeliveryCancel;

--
-- Drop procedure `SP_DeliveryComplitaed`
--
DROP PROCEDURE IF EXISTS SP_DeliveryComplitaed;

--
-- Drop procedure `SP_UsersBookDelivery`
--
DROP PROCEDURE IF EXISTS SP_UsersBookDelivery;

--
-- Drop function `FN_Deliveries`
--
DROP FUNCTION IF EXISTS FN_Deliveries;

--
-- Drop function `FN_DeliveriesDaily`
--
DROP FUNCTION IF EXISTS FN_DeliveriesDaily;

--
-- Drop function `FN_DeliveriesWeekly`
--
DROP FUNCTION IF EXISTS FN_DeliveriesWeekly;

--
-- Drop table `Deliveries`
--
DROP TABLE IF EXISTS Deliveries;

--
-- Drop procedure `SP_UsersResolveAddress`
--
DROP PROCEDURE IF EXISTS SP_UsersResolveAddress;

--
-- Drop function `FN_UsersResolveAddress`
--
DROP FUNCTION IF EXISTS FN_UsersResolveAddress;

--
-- Drop table `Users`
--
DROP TABLE IF EXISTS Users;

--
-- Drop table `DeliveryStatus`
--
DROP TABLE IF EXISTS DeliveryStatus;

--
-- Drop table `Schedule`
--
DROP TABLE IF EXISTS Schedule;

--
-- Set default database
--
USE dropit_shopping;

--
-- Create table `Schedule`
--
CREATE TABLE Schedule (
  TimeSlotID int(11) NOT NULL AUTO_INCREMENT,
  TimeDate timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  DeliveriesCount int(11) DEFAULT 0,
  PRIMARY KEY (TimeSlotID)
)
ENGINE = INNODB,
AUTO_INCREMENT = 6,
AVG_ROW_LENGTH = 3276,
CHARACTER SET latin1,
COLLATE latin1_general_ci;

--
-- Create table `DeliveryStatus`
--
CREATE TABLE DeliveryStatus (
  StatusID tinyint(4) NOT NULL AUTO_INCREMENT,
  StatusName varchar(31) NOT NULL,
  PRIMARY KEY (StatusID)
)
ENGINE = INNODB,
AUTO_INCREMENT = 4,
AVG_ROW_LENGTH = 5461,
CHARACTER SET latin1,
COLLATE latin1_general_ci;

--
-- Create table `Users`
--
CREATE TABLE Users (
  UserID int(11) NOT NULL AUTO_INCREMENT,
  CompanyName varchar(31) NOT NULL,
  ConsulName_2 varchar(31) NOT NULL,
  Address varchar(31) NOT NULL,
  City varchar(31) NOT NULL,
  State varchar(31) NOT NULL,
  ZipCode char(20) DEFAULT NULL,
  Phone_1 char(20) NOT NULL,
  Phone_2 char(20) DEFAULT NULL,
  FormatedAdress json DEFAULT NULL,
  PRIMARY KEY (UserID)
)
ENGINE = INNODB,
AUTO_INCREMENT = 3,
AVG_ROW_LENGTH = 16384,
CHARACTER SET latin1,
COLLATE latin1_general_ci;

DELIMITER $$

--
-- Create function `FN_UsersResolveAddress`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION FN_UsersResolveAddress (UserID int)
RETURNS json
BEGIN
  /*
  Created by: Amitai Ken Korem
  updated: Jun 27 2022
  execute example: 
    SELECT FN_UsersResolveAddress(1);
  */

  DECLARE Data json;
  DECLARE Response json;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;
    RETURN JSON_OBJECT('Status', 500, 'Description', @MSG);
  END;
  SET Data = IFNULL((SELECT
      JSON_OBJECT(
      'State', u.State,
      'City', u.City,
      'Address', u.Address
      )
    FROM Users u
    WHERE u.UserID = UserID), JSON_OBJECT());
  IF (Data IS NOT NULL) THEN
    SET Response = JSON_OBJECT(
    'Data', Data,
    'Status', 200,
    'Description', 'OK');
  ELSE
    SET Response = JSON_OBJECT(
    'Status', 404,
    'Description', CONCAT('UserID: ', UserID, ' not exist'));
  END IF;

  RETURN Response;
END
$$

--
-- Create procedure `SP_UsersResolveAddress`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE SP_UsersResolveAddress (IN UserID int, IN FormatedAdress varchar(255))
BEGIN
  DECLARE Response json;
  DECLARE Data json DEFAULT JSON_OBJECT();
  DECLARE ErrorMessage text;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1
    ErrorMessage = MESSAGE_TEXT;
    SELECT
      JSON_OBJECT('Status', 500, 'Description', ErrorMessage);
    ROLLBACK;
  END;
  START TRANSACTION;
    UPDATE Users u
    SET u.FormatedAdress = FormatedAdress;
  COMMIT;
  SET Response = JSON_OBJECT(
  'Description', CONCAT('UserID: ', UserID, ' FormatedAdress Updated'),
  'Status', 200);
  SELECT
    Response;
END
$$

DELIMITER ;

--
-- Create table `Deliveries`
--
CREATE TABLE Deliveries (
  DeliveryID int(11) NOT NULL AUTO_INCREMENT,
  ScheduleID int(11) NOT NULL,
  UserID int(11) NOT NULL,
  DeliverStatusID tinyint(4) NOT NULL,
  notes text DEFAULT NULL,
  PRIMARY KEY (DeliveryID)
)
ENGINE = INNODB,
AUTO_INCREMENT = 5,
AVG_ROW_LENGTH = 4096,
CHARACTER SET latin1,
COLLATE latin1_general_ci;

--
-- Create index `FK_Deleveries_DeleveryStatus_StatusID` on table `Deliveries`
--
ALTER TABLE Deliveries
ADD INDEX FK_Deleveries_DeleveryStatus_StatusID (DeliverStatusID);

--
-- Create foreign key
--
ALTER TABLE Deliveries
ADD CONSTRAINT FK_Deleveries_DeleverStatusID FOREIGN KEY (DeliverStatusID)
REFERENCES DeliveryStatus (StatusID) ON DELETE NO ACTION;

--
-- Create foreign key
--
ALTER TABLE Deliveries
ADD CONSTRAINT FK_Deleveries_ScheduleID FOREIGN KEY (ScheduleID)
REFERENCES Schedule (TimeSlotID) ON DELETE NO ACTION;

--
-- Create foreign key
--
ALTER TABLE Deliveries
ADD CONSTRAINT FK_Deleveries_UserID FOREIGN KEY (UserID)
REFERENCES Users (UserID) ON DELETE NO ACTION;

DELIMITER $$

--
-- Create function `FN_DeliveriesWeekly`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION FN_DeliveriesWeekly ()
RETURNS json
BEGIN
  DECLARE Data json;
  DECLARE Response json;
  DECLARE CurrentDay int DEFAULT WEEKDAY(NOW());
  DECLARE WeekSunday datetime; -- date(now() + INTERVAL 6 - weekday(now()) DAY);
  DECLARE WeekThursday datetime;--  DEFAULT date(now() + INTERVAL 11 - weekday(now()) DAY);



  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;
    RETURN JSON_OBJECT('Status', 500, 'Description', @MSG);
  END;
  IF (CurrentDay = 6) THEN
    SET WeekSunday = DATE(NOW());
  ELSE
    SET WeekSunday = DATE_SUB(DATE(NOW()), INTERVAL DAYOFWEEK(NOW()) - 1 DAY);
  END IF;
  SET WeekThursday = DATE(NOW() + INTERVAL 4 - WEEKDAY(NOW()) DAY);
  SET Data = (SELECT
      JSON_ARRAYAGG(JSON_OBJECT(
      'DeliveryID', d.DeliveryID,
      'Scheduletimeslot', s.TimeDate,
      'FormatedAddress', u.FormatedAdress,
      'DeliverStatusID', d.DeliverStatusID,
      'notes', d.notes
      ))
    FROM Deliveries d
      LEFT JOIN Schedule s
        ON s.TimeSlotID = d.ScheduleID
      LEFT JOIN Users u
        ON d.UserID = u.UserID
    WHERE s.TimeDate BETWEEN WeekSunday AND WeekThursday);
  IF (Data IS NULL) THEN
    SET Data = JSON_OBJECT();
  END IF;
  SET Response = JSON_OBJECT(
  'Status', 200,
  'Data', Data
  );
  RETURN Response;
END
$$

--
-- Create function `FN_DeliveriesDaily`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION FN_DeliveriesDaily ()
RETURNS json
BEGIN
  DECLARE Data json;
  DECLARE Response json;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;
    RETURN JSON_OBJECT('Status', 500, 'Description', @MSG);
  END;
  SET Data = (SELECT
      JSON_ARRAYAGG(JSON_OBJECT(
      'DeliveryID', d.DeliveryID,
      'Scheduletimeslot', s.TimeDate,
      'FormatedAddress', u.FormatedAdress,
      'DeliverStatusID', d.DeliverStatusID,
      'notes', d.notes
      ))
    FROM Deliveries d
      LEFT JOIN Schedule s
        ON s.TimeSlotID = d.ScheduleID
      LEFT JOIN Users u
        ON d.UserID = u.UserID
    WHERE DATE(s.TimeDate) = DATE(NOW()));
  IF (Data IS NULL) THEN
    SET Data = JSON_OBJECT();
  END IF;
  SET Response = JSON_OBJECT(
  'Status', 200,
  'Data', Data
  );
  RETURN Response;
END
$$

--
-- Create function `FN_Deliveries`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION FN_Deliveries ()
RETURNS json
BEGIN
  DECLARE Data json;
  DECLARE Response json;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;
    RETURN JSON_OBJECT('Status', 500, 'Description', @MSG);
  END;
  SET Data = (SELECT
      JSON_ARRAYAGG(JSON_OBJECT(
      'user', u.CompanyName,
      'timeslotId', s.TimeSlotID
      ))
    FROM Deliveries d
      JOIN Schedule s
        ON d.ScheduleID = s.TimeSlotID
      JOIN Users u
        ON d.UserID = u.UserID);
  IF (Data IS NULL) THEN
    SET Data = JSON_OBJECT();
  END IF;
  SET Response = JSON_OBJECT(
  'Status', 200,
  'Data', Data
  );
  RETURN Response;
END
$$

--
-- Create procedure `SP_UsersBookDelivery`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE SP_UsersBookDelivery (IN DeliveriesBook json)
BEGIN
  DECLARE Response json;
  DECLARE Data json DEFAULT JSON_OBJECT();
  DECLARE ErrorMessage text;
  DECLARE _UserID int DEFAULT JSON_EXTRACT(DeliveriesBook, '$.User');
  DECLARE _TimeSlot int DEFAULT JSON_EXTRACT(DeliveriesBook, '$.Timeslot');
  DECLARE _TimeSlotID int DEFAULT (SELECT
      s.TimeSlotID
    FROM Schedule s
    WHERE s.TimeDate = _TimeSlot);

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1
    ErrorMessage = MESSAGE_TEXT;
    SELECT
      JSON_OBJECT('Status', 500, 'Description', ErrorMessage);
    ROLLBACK;
  END;
  START TRANSACTION;
    IF _TimeSlotID IS NULL THEN
      INSERT INTO Schedule (TimeDate, DeliveriesCount)
        VALUES (_TimeSlot, 1);
      SET _TimeSlotID = LAST_INSERT_ID();
    ELSE
      UPDATE Schedule s
      SET s.DeliveriesCount = s.DeliveriesCount + 1;
    END IF;

    INSERT INTO Deliveries (ScheduleID, UserID, DeliverStatusID, notes)
      VALUES (_TimeSlotID, UserID, 1, '');
  COMMIT;

  SET Response = JSON_OBJECT(
  'Description', CONCAT('UserID ', _UserID, ' added to Timeslot: ', _TimeSlot),
  'Status', 200);
  SELECT
    Response AS Data;
END
$$

--
-- Create procedure `SP_DeliveryComplitaed`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE SP_DeliveryComplitaed (IN DeliveryID int)
BEGIN
  DECLARE Response json;
  DECLARE Data json DEFAULT JSON_OBJECT();
  DECLARE ErrorMessage text;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1
    ErrorMessage = MESSAGE_TEXT;
    SELECT
      JSON_OBJECT('Status', 500, 'Description', ErrorMessage);
    ROLLBACK;
  END;
  START TRANSACTION;
    UPDATE Deliveries d
    SET d.DeliverStatusID = 2
    WHERE d.DeliveryID = DeliveryID;
  COMMIT;
  SET Response = JSON_OBJECT(
  'Description', CONCAT('DeliverID: ', DeliveryID, ' marked as complited'),
  'Status', 200);
  SELECT
    Response;
END
$$

--
-- Create procedure `SP_DeliveryCancel`
--
CREATE
DEFINER = 'root'@'localhost'
PROCEDURE SP_DeliveryCancel (IN _DeliveryID int)
BEGIN
  DECLARE Response json;
  DECLARE Data json DEFAULT JSON_OBJECT();
  DECLARE _ScheduleID int;
  DECLARE _FormatedAdress varchar(255);
  DECLARE _FormatedAdress1 varchar(255);
  DECLARE _FormatedAdress2 varchar(255);
  DECLARE ErrorMessage text;
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1
    ErrorMessage = MESSAGE_TEXT;
    SELECT
      JSON_OBJECT('Status', 500, 'Description', ErrorMessage);
    ROLLBACK;
  END;
  START TRANSACTION;
    SELECT
      d.ScheduleID,
      d.FormatedAdress,
      s.FormatedAdress1,
      s.FormatedAdress2 INTO _ScheduleID, _FormatedAdress, _FormatedAdress1, _FormatedAdress2
    FROM Deliveries d
      INNER JOIN Schedule s
        ON d.ScheduleID = s.TimeSlotID
    WHERE d.DeliveryID = _DeliveryID;
    START TRANSACTION;
      IF (_FormatedAdress = _FormatedAdress2) THEN
        UPDATE Schedule s
        SET s.FormatedAdress2 = NULL
        WHERE s.TimeSlotID = _ScheduleID;
      ELSEIF (_FormatedAdress2 IS NULL) THEN
        DELETE
          FROM Schedule
        WHERE TimeSlotID = _ScheduleID;
      ELSE
        UPDATE Schedule s
        SET s.FormatedAdress1 = s.FormatedAdress2,
            s.FormatedAdress2 = NULL
        WHERE s.TimeSlotID = _ScheduleID;
      END IF;
      DELETE
        FROM Deliveries
      WHERE d.DeliveryID = _DeliveryID;
    COMMIT;
    SET Response = JSON_OBJECT(
    'Description', CONCAT('DeliverID: ', _DeliveryID, ' marked as complited'),
    'Status', 200);
    SELECT
      Response;
  END
  $$

--
-- Create function `FN_ScheduleTimeslots`
--
CREATE
DEFINER = 'root'@'localhost'
FUNCTION FN_ScheduleTimeslots ()
RETURNS json
BEGIN
  DECLARE Data json;
  DECLARE Response json;
  DECLARE NextSunday datetime DEFAULT DATE(NOW() + INTERVAL 6 - WEEKDAY(NOW()) DAY);
  DECLARE NextThursday datetime DEFAULT DATE(NOW() + INTERVAL 11 - WEEKDAY(NOW()) DAY); -- friday 00:00:00

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1 @msg = MESSAGE_TEXT;
    RETURN JSON_OBJECT('Status', 500, 'Description', @MSG);
  END;
  SET Data = (SELECT
      JSON_ARRAYAGG(JSON_OBJECT(
      'TimeSlotID', s.TimeSlotID,
      'TimeDate', s.TimeDate,
      'DeliveriesCount', s.DeliveriesCount
      ))
    FROM Schedule s
    WHERE s.TimeDate BETWEEN NextSunday AND NextThursday);
  IF (Data IS NULL) THEN
    SET Data = JSON_OBJECT();
  END IF;
  SET Response = JSON_OBJECT(
  'Status', 200,
  'Data', Data,
  'NextSunday', NextSunday,
  'NextThursday', NextThursday
  );
  RETURN Response;
END
$$

DELIMITER ;

-- 
-- Dumping data for table Users
--
INSERT INTO Users VALUES
(1, 'Telcom', 'Danni', 'Netiv 4', 'Natanya', 'Israel', NULL, '0505246951', NULL, NULL),
(2, 'Telcom', 'Danni', 'Netiv 9', 'Natanya', 'Israel', NULL, '0505246951', NULL, NULL);

-- 
-- Dumping data for table Schedule
--
INSERT INTO Schedule VALUES
(1, '2022-06-27 13:27:18', 1),
(2, '2022-06-27 13:27:19', 1),
(3, '2022-07-05 13:14:49', 1),
(4, '2022-07-07 13:14:49', 1),
(5, '2022-06-27 13:27:21', 1);

-- 
-- Dumping data for table DeliveryStatus
--
INSERT INTO DeliveryStatus VALUES
(1, 'Not completed'),
(2, 'Completed'),
(3, 'other');

-- 
-- Dumping data for table Deliveries
--
INSERT INTO Deliveries VALUES
(1, 2, 1, 1, NULL),
(2, 3, 1, 1, NULL),
(3, 1, 1, 1, NULL),
(4, 4, 2, 1, NULL);

-- 
-- Restore previous SQL mode
-- 
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;

-- 
-- Enable foreign keys
-- 
/*!40014 SET FOREIGN_KEY_CHECKS = @OLD_FOREIGN_KEY_CHECKS */;